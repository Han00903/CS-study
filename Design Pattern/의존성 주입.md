## Intro
##### 리팩토링 중인 코드에서 의존성 주입 방식을 변경하였다.
##### 그래서 의존성 주입 방식에 대하여 알아본 뒤 리팩토링 과정에서 왜 주입방식을 변경했는지 정리하려고한다.

## 의존성 주입
#### 의존성 주입(Dependency Injection)
 - 의존성 주입은 필요한 객체를 클래스 내부에서 직접 생성하는 것이 아닌 외부에서 객체를 전달받아 사용하는 방식이다.
 - 객체간의 결합도를 줄이고 코드의 재활용을 높이는 중요한 설계 원칙이다.
 - Spring Framework는 IoC(Inversion of Control) 컨테이너를 통해 객체 생성과 의존성 관리를 자동으로 처리한다.
   
#### 의존성 주입의 3가지 방법
  - 생성자 주입(Constructor Injection)
    - 객체를 생설할 때 생성자를 통해 의존성을 주입받음
    - 객체 불변성 보장 및 테스트 용이성이 높으며 순환 참조 문제를 예방할 수 있음
  - 필드 주입(Field Injection)
    - 클래스의 필드에 직접 @Autowired 어노테이션을 통해 의존성을 주입
    - 코드가 간결하지만 객체 불변성 보장이 어렵고 테스트가 복잡해지는 단점이 존재
  - 수정자 주입(Setter Injection)
    - Setter 메서드를 통해 의존성을 주입을 받음
    - 선택적인 의존성 주입이 필요할 때 유용하지만 불변성을 보장하지 못함

## 코드 리팩토링 (필드 주입 -> 생성자 주입)
#### 기존 코드: 필드 주입 방식
![image](https://github.com/user-attachments/assets/0c8ebccf-9060-4400-8b01-20bf625619b0)
- 기존 코드에서는 필드 주입 방식을 사용했다.
- 코드가 간결하고 작성하기 쉬웠기 때문에 사용한 방식이지만 아래의 문제가 발생하여 코드를 리팩토링하기로 하였다.
  - 객체 불변성 미보장: 주입된 객체가 변경될 수 있어 코드 안정성이 떨어졌다.
  - 순환 참조 문제 가능성: 필드 주입에서는 순환 참조가 발생해도 컴파일 단계에서 감지되지 않아 런타임에서만 확인이 가능했다.

#### 리팩토링 후 코드: 생성자 주입 방식
![image](https://github.com/user-attachments/assets/65a27c92-9152-479f-8e26-4df2c51c11f8)
- 리팩토링 후 생성자 주입으로 변경하였고 개선효과는 다음과 같다.
  - 유지보수 향상
    - 기존 필드 주입 방식에서는 의존성을 파악하기 위해 클래스 내부 코드까지 모두 확인해야했다.
    - 그러나 생성자 주입 방식으로 변경함으로써 생성자만으로 필요한 의존성을 명확히 파악할 수 있다.  
  - 객체 불변성 보장
    - final을 통해 주입된 의존 객체가 불변 상태로 유지되므로 동시성 문제를 방지하고 코드 안정성이 향상되었다.
  - 순환 참조 문제 예방
    - 필드 주입에서는 A -> B -> A 형태의 순환 참조 문제가 발생했을 때 런타임에서만 문제를 확인할 수 있었다.
    - 생성자 주입은 컴파일 시점에 순환 참조가 검출되어 문제가 사전에 방지된다.
